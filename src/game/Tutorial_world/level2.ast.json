{"ast":[null,{"children":[0,2,3],"kind":"file","start":[0,0]},{"end":[64,0],"kind":"imports","start":[64,0]},{"children":[4,6,25],"end":[64,0],"kind":"commands","start":[64,0]},{"children":[5],"end":[64,18],"kind":"namespace","start":[64,0]},{"end":[64,10],"kind":"ident","start":[64,10],"value":"tutorial"},{"children":[0,0,0,7,8,15,24,0],"end":[73,3],"kind":"theorem","start":[68,0]},{"end":[68,6],"kind":"ident","start":[68,6],"value":"imp_self"},{"children":[10],"end":[68,15],"kind":"binders","start":[68,15]},{"children":[11],"end":[68,16],"kind":"vars","start":[68,16]},{"children":[9,0,12],"end":[68,16],"kind":"binder_0","start":[68,16]},{"end":[68,16],"kind":"ident","start":[68,16],"value":"P"},{"end":[68,24],"kind":"notation","pexpr":1,"start":[68,20],"value":"exprProp"},{"end":[68,29],"kind":"ident","pexpr":2,"start":[68,28],"value":"P"},{"end":[68,33],"kind":"ident","pexpr":3,"start":[68,32],"value":"P"},{"children":[13,14],"end":[68,33],"kind":"notation","pexpr":4,"start":[68,30],"value":"->"},{"children":[0,0,17,20],"end":[73,3],"kind":"begin","pexpr":119,"start":[69,0]},{"children":[18],"end":[70,9],"kind":"tactic","pexpr":54,"start":[70,2],"value":"intro"},{"children":[19],"end":[70,9],"kind":"parse","pexpr":51,"start":[70,8]},{"end":[70,8],"kind":"ident","start":[70,8],"value":"p"},{"children":[21],"end":[71,9],"kind":"tactic","pexpr":96,"start":[71,2],"value":"exact"},{"children":[23],"end":[71,9],"kind":"parse","pexpr":93,"start":[71,8]},{"end":[71,9],"kind":"ident","pexpr":91,"start":[71,8],"value":"p"},{"children":[22],"end":[71,9],"kind":"expr","start":[71,8]},{"children":[16],"end":[73,3],"kind":"notation","pexpr":120,"start":[69,0],"value":"begin"},{"children":[26],"end":[97,12],"kind":"end","start":[97,0]},{"end":[97,4],"kind":"ident","start":[97,4],"value":"tutorial"}],"comments":[{"end":[62,0],"start":[1,2],"text":"\n# Tutorial World\n\n## Level 2: The `intro`, `exact` and `apply` tactics\n\n## Intro:\n\n`Intro` is a fundamental tactic dealing with propositions in Lean, and here you'll learn how to use it.\n\nIf we have a true/false statement $P$, let's prove something trivial: $P\\implies P$. \n\nConstructing a term of type `P → P` in this case amounts to proving that $P\\implies P$,\nand computer scientists think of this as coming up with a function \nwhich sends proofs of $P$ to proofs of $P$.\n\nTo define an implication $P\\implies Q$ we need to choose an arbitrary\nproof $p : P$ of $P$ and then construct a proof of $Q$, which is\n\"let's assume $P$ is true\". In Lean, this is `intro p`, i.e., \n\"let's assume we have a proof of $P$\" (note that this is the *lowercase* p).\n\n### Template: \n\nIf your goal is to prove anything in the form of `P → Q` (i.e. that $P\\implies Q$),\nthen `intro p`, meaning \"assume $p$ is a proof of $P$\", will make progress.\n\nTo solve the goal below, you have to come up with a function from\n`P` (thought of as the set of proofs of $P$!) to itself. Start with\n\n`intro p,`\n\n(i.e. \"let $p$ be a proof of $P$\") and note that our\nlocal context now looks like this:\n\n```\nP : Prop,\np : P\n⊢ P\n```\n\nOur job now is to construct a proof of $P$. \n\n## Exact: \n`Exact` is another fundamental tactic dealing with propositions. It signals that the expression given should fill the goal exactly. Suppose `h: P → Q` is a hypothesis \nthat $P\\implies Q$, and `p: P` is a proof of `P`. Then `exact h(p)` will close the goal `⊢Q` (if we have a proof for P, namely `p`, then h(p) is a proof for Q). \nYet, for most of the cases, you can use the `apply` tactic, will be introduced later, to substitute `exact`. \n\nContinue what we left there, we need to construct of proof for $P$. But, by assumption, $p$ is a proof of $P$. \n\nSo, `exact p,` will close the goal. \n\nNote that `exact P` will not work -- don't\nconfuse a true/false statement (which could be false!) with a proof.\nWe will stick with the convention of capital letters for propositions\nand small letters for proofs.\n\n### Side Note: \n\nAll of that rewriting you did with `rw` previously\nwas rewriting hypothesis of the form `h : X = Y`, but\nyou can also `rw h` if `h : P ↔ Q`. \n\n"},{"end":[67,0],"start":[65,2],"text":" Lemma : no-side-bar\nIf $P$ is a proposition then $P\\implies P$.\n"},{"end":[82,0],"start":[75,2],"text":"\n## Apply \n`Apply` is the last tactic we have for this level. The apply tactic tries to match the current goal against the conclusion of the type of term. \nThe argument term should be a term well-formed in the local context of the main goal. In other words, `apply h` will simplify the goal by applying the \nhypothesis h (a proof) on it. \n\n(try using `apply p` above to close the lemma!)\n"},{"end":[95,0],"start":[84,2],"text":"\n\n## Summary\n\n· `exact p` means the proof p fill the goal exactly.\n\n· `intro p` means let's assume we have a proof of $P$. \n\n· `apply p` means let's use the implication described by p. \n\n\n"}],"expr":[null,{"sort":0},{"local":{"bi":0,"name":"P","pp":"P","type":1}},{"local":{"bi":0,"name":"P","pp":"P","type":1}},{"Pi":{"bi":0,"body":3,"dom":2,"name":"ᾰ"}},{"const":[["interactive","executor","execute_explicit"],[]]},{"const":["tactic",[]]},{"app":[5,6]},{"const":[["has_bind","seq"],[]]},{"const":[["has_bind","seq"],[]]},{"const":[["has_bind","seq"],[]]},{"const":[["tactic","save_info"],[]]},{"const":[[4,"_",616],[]]},{"prenum":{"args":[],"value":"69"}},{"app":[12,13]},{"prenum":{"args":[],"value":"0"}},{"app":[14,15]},{"annotation":{"args":[16],"name":"anonymous_constructor"}},{"app":[11,17]},{"app":[10,18]},{"const":[["has_bind","seq"],[]]},{"const":[["tactic","save_info"],[]]},{"const":[[4,"_",617],[]]},{"prenum":{"args":[],"value":"70"}},{"app":[22,23]},{"prenum":{"args":[],"value":"2"}},{"app":[24,25]},{"annotation":{"args":[26],"name":"anonymous_constructor"}},{"app":[21,27]},{"app":[20,28]},{"const":[["tactic","istep"],[]]},{"prenum":{"args":[],"value":"70"}},{"app":[30,31]},{"prenum":{"args":[],"value":"2"}},{"app":[32,33]},{"prenum":{"args":[],"value":"70"}},{"app":[34,35]},{"prenum":{"args":[],"value":"2"}},{"app":[36,37]},{"prenum":{"args":[],"value":"17"}},{"app":[38,39]},{"const":[["tactic","interactive","intro"],[]]},{"const":[["option","some"],[0]]},{"const":["name",[]]},{"app":[42,43]},{"const":[["name","mk_string"],[]]},{"string_macro":{"args":[],"value":"p"}},{"app":[45,46]},{"const":[["name","anonymous"],[]]},{"app":[47,48]},{"app":[44,49]},{"annotation":{"args":[50],"name":"as_is"}},{"app":[41,51]},{"app":[40,52]},{"app":[29,53]},{"app":[19,54]},{"app":[9,55]},{"const":[["has_bind","seq"],[]]},{"const":[["tactic","save_info"],[]]},{"const":[[4,"_",618],[]]},{"prenum":{"args":[],"value":"71"}},{"app":[59,60]},{"prenum":{"args":[],"value":"3"}},{"app":[61,62]},{"annotation":{"args":[63],"name":"anonymous_constructor"}},{"app":[58,64]},{"app":[57,65]},{"const":[["has_bind","seq"],[]]},{"const":[["has_bind","seq"],[]]},{"const":[["tactic","save_info"],[]]},{"const":[[4,"_",620],[]]},{"prenum":{"args":[],"value":"71"}},{"app":[70,71]},{"prenum":{"args":[],"value":"2"}},{"app":[72,73]},{"annotation":{"args":[74],"name":"anonymous_constructor"}},{"app":[69,75]},{"app":[68,76]},{"const":[["tactic","istep"],[]]},{"prenum":{"args":[],"value":"71"}},{"app":[78,79]},{"prenum":{"args":[],"value":"2"}},{"app":[80,81]},{"prenum":{"args":[],"value":"71"}},{"app":[82,83]},{"prenum":{"args":[],"value":"2"}},{"app":[84,85]},{"prenum":{"args":[],"value":"20"}},{"app":[86,87]},{"const":[["tactic","interactive","exact"],[]]},{"const":[[4,"_",619],[]]},{"local":{"bi":0,"name":"p","pp":"p","type":90}},{"expr_quote_macro":{"args":[],"reflected":false,"value":91}},{"annotation":{"args":[92],"name":"as_is"}},{"app":[89,93]},{"app":[88,94]},{"app":[77,95]},{"app":[67,96]},{"const":[["tactic","save_info"],[]]},{"const":[[4,"_",621],[]]},{"prenum":{"args":[],"value":"73"}},{"app":[99,100]},{"prenum":{"args":[],"value":"1"}},{"app":[101,102]},{"annotation":{"args":[103],"name":"anonymous_constructor"}},{"app":[98,104]},{"app":[97,105]},{"app":[66,106]},{"app":[56,107]},{"app":[8,108]},{"const":[["tactic","save_info"],[]]},{"const":[[4,"_",622],[]]},{"prenum":{"args":[],"value":"73"}},{"app":[111,112]},{"prenum":{"args":[],"value":"0"}},{"app":[113,114]},{"annotation":{"args":[115],"name":"anonymous_constructor"}},{"app":[110,116]},{"app":[109,117]},{"app":[7,118]},{"annotation":{"args":[119],"name":"by"}}],"file":1,"level":["0"]}